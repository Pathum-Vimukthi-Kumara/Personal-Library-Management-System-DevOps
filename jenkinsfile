pipeline { 
    agent any

    options {
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '15'))
        parallelsAlwaysFailFast()
    }

    parameters {
        string(name: 'COMPOSE_DIR', defaultValue: '/opt/personal-library', description: 'Directory on server containing compose files')
        string(name: 'ANSIBLE_INVENTORY', defaultValue: 'infrastructure/ansible/inventory.ini', description: 'Path to Ansible inventory in repo (DigitalOcean droplet)')
        string(name: 'ANSIBLE_PLAYBOOK', defaultValue: 'infrastructure/ansible/site.yml', description: 'Path to Ansible playbook in repo')
        string(name: 'ANSIBLE_TAGS', defaultValue: '', description: 'Ansible tags to run for deployment (optional)')
        string(name: 'ANSIBLE_CREDENTIALS_ID', defaultValue: 'do-ssh-key', description: 'Jenkins SSH credential ID for Droplet (optional). If empty, uses /var/lib/jenkins/.ssh/id_rsa')
        string(name: 'ANSIBLE_FALLBACK_KEY_PATH', defaultValue: '/var/lib/jenkins/.ssh/id_rsa', description: 'Fallback private key path on Jenkins agent for Ansible (PEM, unencrypted)')
    }

    triggers {
        // Trigger on GitHub push via webhook (configure in Jenkins)
        githubPush()
        // Fallback: Poll GitHub every 5 minutes if webhook fails
        pollSCM('H/5 * * * *')
    }

    environment {
        BACKEND_DIR      = 'Backend'
        FRONTEND_DIR     = 'frontend/frontend'
        IMAGE_TAG_BUILD  = "${env.BUILD_NUMBER}"
        IMAGE_TAG_COMMIT = "${env.GIT_COMMIT?.take(12) ?: env.BUILD_NUMBER}"
        DEFAULT_SSH_KEY  = "${params.ANSIBLE_FALLBACK_KEY_PATH}"
    }

    stages {
                stage('Update Inventory from Terraform (optional)') {
                        steps {
                                dir('infrastructure/terraform') {
                                        sh """
                                                echo "=== Attempting to sync Ansible inventory with Terraform output ==="
                                                if command -v terraform >/dev/null 2>&1; then
                                                    TF_IP=$(terraform output -raw droplet_ip 2>/dev/null || true)
                                                    if [ -n "$TF_IP" ]; then
                                                        echo "Terraform reported droplet IP: $TF_IP"
                                                        sed -i "s/^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+/$TF_IP/" ../ansible/inventory.ini || true
                                                        echo "✓ Updated infrastructure/ansible/inventory.ini"
                                                    else
                                                        echo "Terraform output not available; skipping inventory update"
                                                    fi
                                                else
                                                    echo "Terraform not installed on Jenkins agent; skipping inventory sync"
                                                fi
                                        """
                                }
                        }
                }
        stage('Checkout & Setup') {
            steps {
                checkout scm
                sh """
                    echo "=== Setting up workspace ==="
                    chmod +x ${env.BACKEND_DIR}/mvnw || true
                    echo "✓ Checkout completed"
                """
            }
        }

        stage('Verify Environment') {
            steps {
                sh """
                    echo "=== Environment Verification ==="
                    echo "Workspace: ${env.WORKSPACE}"
                    echo "Git Commit: ${env.GIT_COMMIT}"
                    echo "Backend Dir: ${env.BACKEND_DIR}"
                    echo "Frontend Dir: ${env.FRONTEND_DIR}"

                    echo "=== Directory Structure ==="
                    ls -la ${env.BACKEND_DIR}/ || echo "Backend directory not found"
                    echo "Frontend contents:"
                    ls -la ${env.FRONTEND_DIR}/ || echo "Frontend directory not found"

                    echo "=== Tools Verification ==="
                    docker --version || echo "Docker not available"
                    echo "✓ Environment verification completed"
                """
            }
        }

        stage('SSH Connectivity') {
            steps {
                script {
                    echo "=== Testing SSH connectivity with Ansible ping ==="
                    sh 'if [ -f "' + env.DEFAULT_SSH_KEY + '" ]; then echo "Testing SSH with key at ' + env.DEFAULT_SSH_KEY + '"; ansible --version || (echo "Ansible not installed" && exit 1); ansible -i ' + params.ANSIBLE_INVENTORY + ' app -m ping --private-key ' + env.DEFAULT_SSH_KEY + ' --ssh-common-args="-o StrictHostKeyChecking=no" && echo "✓ SSH connectivity OK" || (echo "WARN: SSH connectivity failed" && exit 0); else echo "ERROR: SSH key not found at ' + env.DEFAULT_SSH_KEY + '"; exit 1; fi'
                }
            }
        }

        // Skipping local backend build; deployment handled entirely by Ansible on target host.

        // Docker build and verification stages removed. Deployment is handled via Ansible.

        stage('Deploy via Ansible') {
            steps {
                dir("${env.WORKSPACE}") {
                    script {
                        echo "=== Deploying via Ansible ==="
                        def tagsArg = params.ANSIBLE_TAGS?.trim() ? "--tags \"${params.ANSIBLE_TAGS}\"" : ""
                        sh 'if [ ! -f "' + env.DEFAULT_SSH_KEY + '" ]; then echo "ERROR: SSH key not found at ' + env.DEFAULT_SSH_KEY + '"; exit 1; fi; echo "Running ansible-playbook with key ' + env.DEFAULT_SSH_KEY + '"; export ANSIBLE_HOST_KEY_CHECKING=False; ansible-playbook -i ' + params.ANSIBLE_INVENTORY + ' ' + params.ANSIBLE_PLAYBOOK + ' --private-key ' + env.DEFAULT_SSH_KEY + ' ' + tagsArg + ' -v && echo "✓ Ansible deployment completed"'
                        }
                    }
                }
            }
        }

        stage('Smoke Test') {
            steps {
                script {
                    def inv = readFile('infrastructure/ansible/inventory.ini')
                    def lines = inv.readLines()
                    def dropletIp = ''
                    def inApp = false
                    for (def raw : lines) {
                        def l = raw.trim()
                        if (l.startsWith('[')) {
                            inApp = (l == '[app]')
                            continue
                        }
                        if (inApp && l && !l.startsWith('#') && !l.startsWith('[')) {
                            dropletIp = l.split(/\s+/)[0]
                            break
                        }
                    }
                    if (!dropletIp) {
                        error 'Droplet IP not found in inventory [app] group'
                    }
                    env.DROPLET_IP = dropletIp
                }
                sh """
                    echo "=== Smoke Test ==="
                    echo "Checking frontend at http://${DROPLET_IP}:3008"
                    curl -sSf -m 20 http://${DROPLET_IP}:3008 | head -c 200 > /dev/null
                    echo "✓ Frontend reachable"
                    echo "Checking backend health at http://${DROPLET_IP}:5001/actuator/health (optional)"
                    curl -s -m 10 http://${DROPLET_IP}:5001/actuator/health || true
                """
            }
        }
    }

    post {
        success {
            echo 'PIPELINE SUCCESSFUL!'
        }
        failure {
            echo 'PIPELINE FAILED!'
            sh """
                echo "=== Debug Information ==="
                echo "Current directory:"
                pwd
                ls -la
            """
        }
        always {
            echo '=== Post Build Cleanup ==='
            sh """
                echo "No Docker cleanup required for Ansible-only pipeline"
            """
        }
    }
}