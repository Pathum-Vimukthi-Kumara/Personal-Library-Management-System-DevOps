pipeline {
    agent any

    options {
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '20'))
        parallelsAlwaysFailFast()
    }

    parameters {
        string(name: 'DROPLET_HOST', defaultValue: '143.198.162.25', description: 'DigitalOcean droplet IP or hostname')
        string(name: 'SSH_USER', defaultValue: 'ansible', description: 'SSH user on droplet')
        string(name: 'SSH_CREDENTIALS_ID', defaultValue: 'do-ssh-key', description: 'Jenkins SSH credential ID (Private Key)')
        string(name: 'REMOTE_DIR', defaultValue: '/opt/personal-library', description: 'Remote directory with compose files')
        string(name: 'COMPOSE_FILE', defaultValue: 'compose.yaml', description: 'Compose file to use')
        string(name: 'BRANCH', defaultValue: 'master', description: 'Git branch to deploy')

        // Ansible-related
        string(name: 'ANSIBLE_INVENTORY', defaultValue: 'infrastructure/ansible/inventory.ini', description: 'Path to Ansible inventory')
        string(name: 'ANSIBLE_PLAYBOOK', defaultValue: 'infrastructure/ansible/site.yml', description: 'Path to Ansible playbook')
        string(name: 'ANSIBLE_TAGS', defaultValue: 'app', description: 'Ansible tags to run')

        // Optional SSH fallback
        booleanParam(name: 'ENABLE_SSH_DEPLOY', defaultValue: false, description: 'Enable SSH-based deploy (fallback)')
    }

    triggers {
        githubPush()
    }

    environment {
        BACKEND_DIR  = 'Backend'
        FRONTEND_DIR = 'frontend/frontend'
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
                sh 'echo "âœ“ Code checked out"'
            }
        }

        stage('Verify Workspace') {
            steps {
                sh '''
                    echo "Backend dir:"
                    ls -la ${BACKEND_DIR} || true
                    echo "Frontend dir:"
                    ls -la ${FRONTEND_DIR} || true
                '''
            }
        }

        stage('Provision: Ansible') {
            steps {
                script {
                    def inv  = params.ANSIBLE_INVENTORY.trim()
                    def play = params.ANSIBLE_PLAYBOOK.trim()
                    def tags = params.ANSIBLE_TAGS.trim()
                    def tagsArg = tags ? "--tags ${tags}" : ""

                    def hasAnsible = sh(
                        script: 'command -v ansible-playbook >/dev/null 2>&1',
                        returnStatus: true
                    ) == 0

                    if (!hasAnsible) {
                        error 'Ansible is not installed on Jenkins controller'
                    }

                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: params.SSH_CREDENTIALS_ID,
                            keyFileVariable: 'SSH_KEY'
                        )
                    ]) {
                        sh """
                            set -e
                            echo "=== Deploying via Ansible ==="
                            export ANSIBLE_HOST_KEY_CHECKING=False
                            ansible-playbook -i ${inv} ${play} \
                              -e ansible_ssh_private_key_file="\$SSH_KEY" \
                              ${tagsArg} -vv
                        """
                    }
                }
            }
        }

        stage('Deploy: SSH Fallback') {
            when {
                expression { return params.ENABLE_SSH_DEPLOY }
            }
            steps {
                script {
                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: params.SSH_CREDENTIALS_ID,
                            keyFileVariable: 'SSH_KEY'
                        )
                    ]) {
                        sh """
                            set -e
                            echo "=== SSH Deploy Fallback ==="
                            ssh -i "\$SSH_KEY" -o StrictHostKeyChecking=no \
                            ${params.SSH_USER}@${params.DROPLET_HOST} "bash -lc '
                                set -e
                                sudo chown -R ${params.SSH_USER}:${params.SSH_USER} ${params.REMOTE_DIR} || true
                                git config --global --add safe.directory ${params.REMOTE_DIR}
                                cd ${params.REMOTE_DIR}
                                git fetch origin ${params.BRANCH}
                                git reset --hard origin/${params.BRANCH}
                                docker compose -f ${params.COMPOSE_FILE} down || true
                                    # Rebuild images pulling latest base layers
                                    docker compose -f ${params.COMPOSE_FILE} build --pull
                                    docker compose -f ${params.COMPOSE_FILE} up -d
                                sudo systemctl restart nginx || true
                            '"
                        """
                    }
                }
            }
        }

        stage('Smoke Test') {
            steps {
                sh '''
                    echo "Testing HTTP root"
                    curl -sSf -m 20 http://${DROPLET_HOST} -I || true

                    echo "Testing frontend"
                    curl -sSf -m 20 http://${DROPLET_HOST}:3008 | head -c 200 || true

                    echo "Waiting for backend health"
                    for i in $(seq 1 60); do
                      resp=$(curl -s -m 5 http://${DROPLET_HOST}:5001/actuator/health || true)
                      echo "$resp" | grep -q '"status":"UP"' && { echo "Backend is UP"; break; }
                      sleep 2
                    done

                    echo "Final backend health response:"
                    curl -s -m 10 http://${DROPLET_HOST}:5001/actuator/health || true
                '''
            }
        }
    }

    post {
        success { echo 'PIPELINE SUCCESSFUL!' }
        failure { echo 'PIPELINE FAILED!' }
        always  { echo '=== Pipeline finished ===' }
    }
}
