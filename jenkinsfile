pipeline {
    agent any

    options {
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '20'))
    }

    parameters {
        string(name: 'DROPLET_HOST', defaultValue: '45.55.107.160', description: 'DigitalOcean droplet IP / Reserved IP')
        string(name: 'SSH_USER', defaultValue: 'ansible', description: 'SSH user on droplet')
        string(name: 'SSH_CREDENTIALS_ID', defaultValue: 'do-ssh-key', description: 'Jenkins SSH key credential ID')
        string(name: 'REMOTE_DIR', defaultValue: '/opt/personal-library', description: 'App directory on droplet')
        string(name: 'COMPOSE_FILE', defaultValue: 'compose.yaml', description: 'Docker compose file')
        string(name: 'BRANCH', defaultValue: 'master', description: 'Git branch to deploy')

        // Ansible
        string(name: 'ANSIBLE_INVENTORY', defaultValue: 'infrastructure/ansible/inventory.ini')
        string(name: 'ANSIBLE_PLAYBOOK', defaultValue: 'infrastructure/ansible/site.yml')
        string(name: 'ANSIBLE_TAGS', defaultValue: 'app')

        // Optional SSH fallback
        booleanParam(name: 'ENABLE_SSH_DEPLOY', defaultValue: false, description: 'Enable SSH fallback deploy')
    }

    triggers {
        githubPush()
    }

    environment {
        BACKEND_DIR  = 'Backend'
        FRONTEND_DIR = 'frontend/frontend'
    }

    stages {

        /* ================= CHECKOUT ================= */

        stage('Checkout') {
            steps {
                checkout scm
                sh 'echo "âœ“ Code checked out"'
            }
        }

        stage('Verify Workspace') {
            steps {
                sh '''
                    echo "Backend:"
                    ls -la ${BACKEND_DIR} || true
                    echo "Frontend:"
                    ls -la ${FRONTEND_DIR} || true
                '''
            }
        }

        /* ================= ANSIBLE DEPLOY (PRIMARY) ================= */

        stage('Deploy: Ansible (Primary)') {
            steps {
                script {
                    def hasAnsible = sh(
                        script: 'command -v ansible-playbook >/dev/null 2>&1',
                        returnStatus: true
                    ) == 0

                    if (!hasAnsible) {
                        error 'Ansible is not installed on Jenkins'
                    }

                    withCredentials([
                        sshUserPrivateKey(
                            credentialsId: params.SSH_CREDENTIALS_ID,
                            keyFileVariable: 'SSH_KEY'
                        )
                    ]) {
                        sh """
                            set -e
                            echo "=== Deploying via Ansible (FORCED REBUILD) ==="
                            export ANSIBLE_HOST_KEY_CHECKING=False
                            ansible-playbook \
                              -i ${params.ANSIBLE_INVENTORY} \
                              ${params.ANSIBLE_PLAYBOOK} \
                              --tags ${params.ANSIBLE_TAGS} \
                              -e ansible_ssh_private_key_file="\$SSH_KEY" \
                              -vv
                        """
                    }
                }
            }
        }

        /* ================= SSH FALLBACK (OPTIONAL) ================= */

        stage('Deploy: SSH Fallback') {
            when {
                expression { return params.ENABLE_SSH_DEPLOY }
            }
            steps {
                withCredentials([
                    sshUserPrivateKey(
                        credentialsId: params.SSH_CREDENTIALS_ID,
                        keyFileVariable: 'SSH_KEY'
                    )
                ]) {
                    sh """
                        set -e
                        echo "=== SSH Fallback Deploy (FORCED REBUILD) ==="
                        ssh -i "\$SSH_KEY" -o StrictHostKeyChecking=no \
                        ${params.SSH_USER}@${params.DROPLET_HOST} <<'EOF'
                            set -e
                            cd ${params.REMOTE_DIR}
                            sudo chown -R ${params.SSH_USER}:${params.SSH_USER} .
                            git config --global --add safe.directory ${params.REMOTE_DIR}
                            git fetch origin ${params.BRANCH}
                            git reset --hard origin/${params.BRANCH}

                            docker compose -f ${params.COMPOSE_FILE} down || true
                            docker compose -f ${params.COMPOSE_FILE} build --no-cache --pull
                            docker compose -f ${params.COMPOSE_FILE} up -d

                            sudo systemctl restart nginx || true
EOF
                    """
                }
            }
        }

        /* ================= SMOKE TEST ================= */

        stage('Smoke Test') {
            steps {
                sh '''
                    echo "HTTP root:"
                    curl -sSf -m 20 http://${DROPLET_HOST} -I || true

                    echo "Frontend:"
                    curl -sSf -m 20 http://${DROPLET_HOST}:3008 | head -c 200 || true

                    echo "Waiting for backend health via frontend proxy"
                    for i in $(seq 1 60); do
                      resp=$(curl -s -m 5 http://${DROPLET_HOST}:3008/api/actuator/health || true)
                      echo "$resp" | grep -q '"status":"UP"' && break
                      sleep 2
                    done

                    curl -s -m 10 http://${DROPLET_HOST}:3008/api/actuator/health || true
                '''
            }
        }
    }

    post {
        success { echo 'PIPELINE SUCCESSFUL!' }
        failure { echo 'PIPELINE FAILED!' }
        always  { echo '=== Pipeline finished ===' }
    }
}
